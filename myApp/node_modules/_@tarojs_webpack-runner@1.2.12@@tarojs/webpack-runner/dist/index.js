"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const opn = require("opn");
const path = require("path");
const url_1 = require("url");
const util_1 = require("util");
const webpack = require("webpack");
const WebpackDevServer = require("webpack-dev-server");
const webpackMerge = require("webpack-merge");
const build_conf_1 = require("./config/build.conf");
const dev_conf_1 = require("./config/dev.conf");
const devServer_conf_1 = require("./config/devServer.conf");
const dll_conf_1 = require("./config/dll.conf");
const prod_conf_1 = require("./config/prod.conf");
const util_2 = require("./util");
const logHelper_1 = require("./util/logHelper");
const customizeChain = (chain, customizeFunc) => {
    if (customizeFunc instanceof Function) {
        customizeFunc(chain, webpack);
    }
};
const deprecatedCustomizeConfig = util_1.deprecate((baseConfig, customConfig) => {
    if (customConfig instanceof Function) {
        return customConfig(baseConfig, webpack);
    }
    else if (customConfig instanceof Object) {
        return webpackMerge({}, baseConfig, customConfig);
    }
}, chalk_1.default.yellow(`h5.webpack配置项即将停止支持，请尽快迁移到新配置项。新配置项文档：https://nervjs.github.io/taro/docs/config-detail.html#h5`));
const buildDll = (config) => __awaiter(this, void 0, void 0, function* () {
    if (config.enableDll === false)
        return Promise.resolve();
    return new Promise((resolve, reject) => {
        const webpackChain = dll_conf_1.default(config);
        customizeChain(webpackChain, config.dllWebpackChain);
        const webpackConfig = webpackChain.toConfig();
        const compiler = webpack(webpackConfig);
        logHelper_1.bindDllLogger(compiler);
        compiler.run((err) => {
            if (err) {
                logHelper_1.printBuildError(err);
                return reject(err);
            }
            resolve();
        });
    });
});
const buildProd = (config) => {
    return new Promise((resolve, reject) => {
        const webpackChain = prod_conf_1.default(config);
        let webpackConfig;
        customizeChain(webpackChain, config.webpackChain);
        if (config.webpack) {
            webpackConfig = deprecatedCustomizeConfig(webpackChain.toConfig(), config.webpack);
        }
        else {
            webpackConfig = webpackChain.toConfig();
        }
        const compiler = webpack(webpackConfig);
        logHelper_1.bindProdLogger(compiler);
        compiler.run((err) => {
            if (err) {
                logHelper_1.printBuildError(err);
                return reject(err);
            }
            resolve();
        });
    });
};
const buildDev = (config) => __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        const conf = build_conf_1.default(config);
        const routerConfig = config.router || {};
        const routerMode = routerConfig.mode === 'browser' ? 'browser' : 'hash';
        const routerBasename = routerConfig.basename || '/';
        const publicPath = conf.publicPath ? util_2.addLeadingSlash(util_2.addTrailingSlash(conf.publicPath)) : '/';
        const outputPath = path.join(util_2.appPath, conf.outputRoot);
        const customDevServerOption = config.devServer || {};
        const webpackChain = dev_conf_1.default(config);
        let webpackConfig;
        customizeChain(webpackChain, config.webpackChain);
        webpackConfig = webpackChain.toConfig();
        if (config.webpack) {
            webpackConfig = deprecatedCustomizeConfig(webpackChain.toConfig(), config.webpack);
        }
        const devServerOptions = util_2.recursiveMerge({
            publicPath,
            contentBase: outputPath,
            historyApiFallback: {
                index: publicPath
            }
        }, devServer_conf_1.default, customDevServerOption);
        const devUrl = url_1.format({
            protocol: devServerOptions.https ? 'https' : 'http',
            hostname: devServerOptions.host,
            port: devServerOptions.port,
            pathname: routerMode === 'browser' ? routerBasename : '/'
        });
        WebpackDevServer.addDevServerEntrypoints(webpackConfig, devServerOptions);
        const compiler = webpack(webpackConfig);
        logHelper_1.bindDevLogger(devUrl, compiler);
        const server = new WebpackDevServer(compiler, devServerOptions);
        server.listen(devServerOptions.port, devServerOptions.host, err => {
            if (err) {
                reject();
                return console.log(err);
            }
            resolve();
            /* 补充处理devServer.open配置 */
            if (devServerOptions.open) {
                opn(devUrl);
            }
        });
    });
});
exports.default = (config) => __awaiter(this, void 0, void 0, function* () {
    if (config.isWatch) {
        yield buildDev(config);
    }
    else {
        yield buildDll(config);
        yield buildProd(config);
    }
});
